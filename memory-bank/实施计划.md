---

## 一、基础功能实施计划（Phase 1：Dexie + 书架）

### 步骤 1：梳理现有项目结构和入口

- **实施指令**
  - 在 IDE 中打开项目根目录，熟悉以下内容：
    - 当前前端入口文件（例如 main.ts）如何挂载根组件。
    - 路由配置文件中，默认路由指向的是哪个页面（目前很可能是阅读器）。
    - 现有的视图目录（views）和组件目录（components）结构。
  - 记录当前“阅读器视图”的文件名和路径，用于后续从书架跳转。

- **测试方法**
  - 启动本地开发服务器。
  - 在浏览器中访问首页，确认当前默认页面正常显示且阅读功能仍可使用。
  - 在浏览器控制台检查是否有报错或严重警告。

---

### 步骤 2：为新架构准备基础目录和模块划分

- **实施指令**
  - 在项目中确认或创建以下目录（仅结构，不必实现逻辑）：
    - src/views：用于页面级组件（如书架页）。
    - src/components：放纯 UI 组件（例如单个书籍卡片）。
    - src/services：放与 Dexie 数据库、AI API 等无关 UI 的纯 TypeScript 模块。
    - src/composables：放与业务状态相关的 Composition API 钩子（例如书架状态）。
  - 定义一个专门用于“书架”的视图文件（例如 BookshelfView）和一个基本的布局草图（网格或列表概念即可）。

- **测试方法**
  - 在路由中临时添加一条指向“书架视图”的测试路由（不必设为默认）。
  - 访问该测试路由，确认页面可以正常渲染一个简单的占位内容（例如标题“书架”）。
  - 确认没有对现有阅读器功能造成破坏。

---

### 步骤 3：引入 Dexie.js 并规划数据库 schema

- **实施指令**
  - 将 Dexie.js 加入项目依赖（如果尚未存在）。
  - 在 src/services 下规划一个专门管理本地数据库的模块，例如“db 服务”：
    - 明确其中需要包含两张表：books 和 vocabulary（此阶段仅实现 books 表）。
    - 按设计文档和《结构.md》中的字段定义 books 表字段（id、title、author、cover、data、lastRead、progress），其中 progress 明确定义为 0–1 的浮点数进度值。
  - 确保该服务文件不依赖任何 Vue 组件，仅是纯 TypeScript 逻辑。

- **测试方法**
  - 在浏览器的开发者工具中打开 Application / Storage / IndexedDB 面板。
  - 在应用启动时，确认 Dexie 创建的数据库和 books 表如期出现，无错误报错。
  - 刷新页面几次，确保数据库初始化过程没有因重复执行而报错。

---

### 步骤 4：实现“导入书籍”基础 UI（不含解析）

- **实施指令**
  - 在书架视图中添加一个“导入书籍”按钮和文件选择交互：
    - 按设计文档要求，使用文件选择来获取本地电子书文件（支持 EPUB/MOBI/AZW3 等）。
  - 通过一个 composable（位于 src/composables，比如书架相关的 useBookshelf）来集中处理导入逻辑入口（此阶段仅规划调用，不实现解析逻辑）。

- **测试方法**
  - 在浏览器中打开书架页面。
  - 点击“导入书籍”按钮，确认可以弹出系统文件选择对话框。
  - 选择一个电子书文件，确认页面不会出现报错（即使此时仍未真正解析或保存）。

---

### 步骤 5：整合解析库，抽取书籍元数据

- **实施指令**
  - 熟悉项目中已有的电子书解析库位置（如 packages 下的 epub/mobi 解析包）。
  - 在 src/services 下规划一个“电子书解析服务”模块：
    - 输入：文件对象。
    - 输出：只包含元数据的结构，例如书名、作者、封面信息，以及需要存入 data 字段的原始文件内容。
  - 在书架相关的 composable 中调用该解析服务：
    - 解析出 title、author、cover 等字段。
    - 将原始文件内容准备好，后续交给 Dexie 存储。

- **测试方法**
  - 在浏览器中使用几个不同格式的示例电子书进行导入：
    - 导入成功时，在开发者工具中打印或在界面上临时展示解析出的标题和作者。
  - 针对错误格式或损坏的文件：
    - 确认能优雅地提示“导入失败”而不是抛出未捕获错误。

---

### 步骤 6：将书籍元数据和文件保存到 IndexedDB（books 表）

- **实施指令**
  - 在书架的 composable 中，通过数据库服务，将解析后的书籍数据写入 books 表：
    - 确保 data 字段存储为 Blob 或合适的二进制结构。
    - lastRead 初始可以设为当前时间或空值。
    - progress 初始为 0 或一个明确的初始结构。
  - 注意性能要求：仅在导入时写入 data 字段，在后续列表展示时不要读取 data 字段。

- **测试方法**
  - 导入一本书后，打开浏览器 IndexedDB 面板：
    - 检查 books 表中是否新增一条记录，字段值是否符合设计文档定义。
  - 刷新页面后再次检查：
    - 确认该记录仍然存在（证明持久化成功）。

---

### 步骤 7：实现书架列表/网格展示（仅使用元数据）

- **实施指令**
  - 在 src/components 中设计纯 UI 组件，用于展示单本书的封面和标题（书籍卡片组件），样式优先使用 Tailwind CSS（在不破坏现有样式体系的前提下）。
  - 在书架视图中：
    - 通过书架 composable 从 Dexie 异步读取所有书籍元数据（不读取 data 字段）。
    - 按 lastRead 字段或导入顺序排序。
    - 使用网格（桌面）和列表/双列网格（移动端）布局展示书籍卡片。
  - 确保 UI 组件不直接操作数据库，仅通过 props 接收元数据。

- **测试方法**
  - 连续导入多本不同的书：
    - 检查书架页面是否立即出现新卡片。
    - 确认刷新浏览器后，书架仍然展示所有已导入的书籍。
  - 在桌面与移动端视口宽度下手动调节浏览器宽度：
    - 检查布局是否自动切换为网格或列表样式，避免水平滚动条和过度压缩。

---

### 步骤 8：实现从书架跳转到阅读器并加载文件

- **实施指令**
  - 为书籍卡片组件添加点击交互：
    - 点击时，通过书架 composable 调用数据库服务，从 books 表按 id 读取对应记录，拿到 `id` 与必要元数据。
    - 路由跳转时，通过路由参数传递 `bookId`（对应 books.id），在阅读器视图内部根据 `bookId` 再从 Dexie 中按需读取 `data` Blob 并交给现有阅读渲染管线。
  - 在跳转时更新 lastRead 字段为当前时间，以支持后续按最近阅读排序。

- **测试方法**
  - 从书架上点击任意一本书：
    - 检查是否正确跳转到原有阅读器页面。
    - 确认阅读器可以正常渲染新导入的电子书内容。
  - 返回书架后：
    - 确认刚刚阅读过的书籍在列表中排序靠前（如果使用 lastRead 排序）。
  - 打开浏览器 IndexedDB 面板：
    - 检查对应记录的 lastRead 是否更新。

---

### 步骤 9：将书架设为默认首页，确保回退路径合理

- **实施指令**
  - 在路由配置中，将默认路由从阅读器修改为书架视图。
  - 确保仍然保留阅读器独立路由，以便直接调试阅读页面。
  - 在阅读器视图中添加回到书架的导航入口（例如顶部返回按钮或菜单项）。

- **测试方法**
  - 重新加载应用根路径：
    - 确认进入的是书架页面，而不是直接进入阅读器。
  - 从书架进入阅读器，阅读一段后使用返回入口：
    - 确认能够返回书架且状态正常（列表完整、排序正常）。

---

### 步骤 10：基础稳定性与回归测试

- **实施指令**
  - 在不同浏览器（至少 Chrome 和一个移动端浏览器）上重复以下步骤：
    - 首次导入一本书，确认显示正常。
    - 关闭浏览器标签页并重新打开应用，确认书架数据仍在。
    - 导入多本书后，快速频繁切换阅读器和书架页面。
  - 记录在任何一步中出现的异常或性能问题（例如加载过慢、卡顿）。

- **测试方法**
  - 使用浏览器性能面板观测：
    - 导入书籍时主线程是否长时间阻塞。
    - 书架列表展示是否伴随明显卡顿。
  - 进行一次完整的“从无到有”的用户流程自测：
    - 打开应用 → 看到空书架 → 导入书 → 书出现在书架 → 点击进入阅读器 → 返回书架 → 刷新浏览器 → 书仍在。

---

## 二、完整功能与扩展功能实施计划（Phase 2–4 概览）

> 本部分为后续阶段的路线图，每一步同样包含实现要点与验证方式，但细节程度略低，待基础功能稳定后再逐项展开。

### Phase 2：AI 接入与选区菜单

1. **实现设置页与 API Key 管理**
   - 实施指令：新增设置视图，提供表单让用户输入并保存 AI 接口 Key 到浏览器本地存储（使用固定 key 名 `lingoReader.apiKey`）；提供“清除 Key”入口。
   - 测试方法：输入、刷新、重新进入设置页，确认 Key 能正确读写；使用无效 Key 时，AI 请求能返回友好错误提示。

2. **在阅读器中监听文本选中事件**
   - 实施指令：在阅读器渲染完成后，添加对 mouseup 和 touchend 的监听逻辑，检测当前选中的文本内容和上下文句子。
   - 测试方法：分别用鼠标和触屏设备选中一段文字，确认能捕获到选中内容，并在控制台输出调试信息，无异常报错。

3. **实现浮动菜单（翻译/解释 | 加入生词本）**
   - 实施指令：基于当前选区位置绘制一个浮动菜单组件，提供至少两个操作：请求 AI 解释、加入生词本。菜单样式优先使用 Tailwind CSS，并确保移动端与桌面端布局兼容。
   - 测试方法：在不同位置选中文字，检查浮动菜单是否贴近选区且不遮挡文本，滚动页面后菜单是否正确消失或重定位。

4. **集成 AI 接口并流式展示结果**
   - 实施指令：在 src/services 下实现专门的 AI 客户端服务，封装对 OpenAI 或兼容接口的前端直连调用（BYOK 模式，用户自带 Key），使用设计文档给出的 prompt 模板；设计该服务为可插拔接口层，后续可无痛替换不同模型或厂商；在 UI 中以逐字或逐行的形式流式显示返回内容。
   - 测试方法：在网络较慢环境下测试一次请求，观察界面是否快速显示“正在分析”状态，并逐步出现 AI 返回内容，错误情况是否有清晰提示。

---

### Phase 3：生词本与高亮

5. **生词本表结构与写入逻辑**
   - 实施指令：在 Dexie 数据库中正式启用 vocabulary 表（字段结构以《结构.md》为准）；在用户选中文字并点击“加入生词本”时，将 word、context、aiExplanation、bookId、createdAt 等字段写入。
   - 测试方法：多次保存不同单词，检查 IndexedDB 中 vocabulary 表记录是否正确、字段是否完整。

6. **章节渲染后从 vocabulary 拉取数据**
   - 实施指令：在阅读器加载章节内容时，调用数据库服务获取与当前书籍相关的所有生词列表。
   - 测试方法：切换不同书籍，确认每本书加载后，内存中仅存在该书籍相关的生词集合。

7. **在 DOM 文本节点中高亮生词**
   - 实施指令：在阅读器渲染完成后的钩子中，遍历可见文本节点，对照生词列表进行匹配：
     - 匹配时不区分大小写。
     - 在实现层尽量覆盖常见词形变化（如过去式、进行时、复数等），避免仅限于原始形态。
     - 使用完整单词边界，避免在其他单词内部误匹配。
     - 所有匹配到的出现位置都需要高亮，不只高亮第一次出现。
     - 将匹配到的词包裹为可点击的标记元素，并应用统一的样式（如下划线和红色波浪线风格）。
   - 测试方法：在页面中滚动浏览，确认所有已保存的生词在本页的每次出现都被正确高亮；检查未保存的词不会被误高亮；在大段文本中确认渲染性能可接受。

8. **点击生词高亮弹出生词卡片**
   - 实施指令：为高亮标记绑定点击事件，在移动端使用底部弹出抽屉，在桌面端使用侧边弹窗或气泡，展示 AI 解释、例句等信息，并提供删除或重新分析按钮；对于同一个生词的多个高亮实例，点击任意一个都展示同一条生词记录对应的卡片。
   - 测试方法：在移动端浏览器和桌面浏览器中分别点击多个高亮词，确认弹窗位置合理、不遮挡关键内容，重复点击不会产生多个重叠弹窗。

---

### Phase 4：移动端优化与部署

9. **优化触摸交互与点击区域**
   - 实施指令：根据设计文档，将屏幕左右 20% 区域定义为翻页触发区，中间 60% 作为选中与菜单区域；确保选中文字与翻页手势不会冲突。
   - 测试方法：在实际手机设备上测试：轻点左右边缘触发翻页；长按并拖动中间区域能够正常选中并出现 AI 菜单。

10. **完善响应式布局与视口配置**
    - 实施指令：检查并确保 index.html 的视口配置禁止用户缩放；在书架、阅读器、生词弹窗等页面统一应用移动优先的布局策略，新增加的布局和组件优先使用 Tailwind CSS 来快速构建响应式样式。
    - 测试方法：使用浏览器设备模拟和真实手机，查看不同分辨率下的整体布局，确认没有超出屏幕或需要横向滚动。

11. **Vercel 构建与部署**
    - 实施指令：根据设计文档，在 Vercel 控制台配置项目：选择 Vite 框架，设置构建命令和输出目录，并配置路由重写以支持前端路由。
    - 测试方法：
      - 触发一次构建，确认构建日志无错误。
      - 打开部署后的 URL，完整走一遍用户流程（导入书 → 书架展示 → 阅读 → 选词 AI 分析 → 生词高亮），确保线上行为与本地一致。

> 所有新增 UI 文案（按钮文本、错误提示、设置项说明等）在实现时必须通过项目的 i18n 文案文件维护，不直接写死在组件内，确保后续可以轻松扩展多语言。
