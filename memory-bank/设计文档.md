这份设计文档旨在基于 `lingo-reader` 现有的 Vue 3 + TypeScript 架构，通过引入客户端数据库（IndexedDB）和 AI 接口，将其改造为具备“书架管理”与“AI 辅助阅读”功能的 Web 应用。

---

# Lingo-Reader 增强版设计文档

## 1. 系统架构与技术选型

由于目标是部署在 Vercel 且保持轻量，我们将采用 **“纯前端 + 本地存储 + Serverless AI”** 的架构。

*   **前端框架**: Vue 3 (Composition API) + TypeScript (沿用原项目)
*   **本地数据库**: **Dexie.js** (基于 IndexedDB 的封装库)
    *   *用途*: 存储电子书文件(Blob)、书架元数据、生词本数据。
*   **UI 框架**: 推荐引入 **Tailwind CSS** 或 **Naive UI** (移动端适配好)
    *   *用途*: 快速构建响应式书架、弹窗卡片。
*   **AI 集成**: **Vercel AI SDK** 或直接调用 OpenAI/Anthropic API。
*   **部署平台**: Vercel (静态托管 + 可选 Edge Functions)。

---

## 2. 数据库设计 (Schema)

使用 `Dexie.js` 在浏览器本地建立两个核心表：

### 2.1 书架表 (`books`)
| 字段名 | 类型 | 说明 |
| :--- | :--- | :--- |
| `id` | number (自增) | 主键 |
| `title` | string | 书名 |
| `author` | string | 作者 |
| `cover` | blob/base64 | 封面图片 |
| `data` | blob | 电子书源文件 (EPUB/MOBI/AZW3) |
| `lastRead` | timestamp | 最后阅读时间 (用于排序) |
| `progress` | object | 阅读进度 (CFI 或百分比) |

### 2.2 生词本表 (`vocabulary`)
| 字段名 | 类型 | 说明 |
| :--- | :--- | :--- |
| `id` | string (UUID) | 主键 |
| `word` | string | 单词或短语 (索引字段) |
| `context` | string | 原文例句 |
| `aiExplanation` | string | AI 生成的解释 |
| `bookId` | number | 来源书籍 ID |
| `createdAt` | timestamp | 加入时间 |

---

## 3. 功能模块详细设计

### 3.1 书架功能 (Home View)
*   **入口**: 将默认路由从阅读器改为书架页。
*   **布局**:
    *   **Desktop**: 网格布局展示封面。
    *   **Mobile**: 列表布局或双列网格。
*   **交互**:
    *   “导入书籍”按钮：调用 `<input type="file">`，解析元数据后存入 IndexedDB `books` 表。
    *   点击封面：从 DB 读取 Blob 数据，跳转至阅读器页面并传递数据。

### 3.2 AI 分析与生词本 (Selection Menu)
*   **触发**: 监听阅读器的文本选中事件 (`mouseup` / `touchend`)。
*   **UI**: 在选中文本上方弹出浮动菜单 [ 翻译/解释 | 加入生词本 ]。
*   **AI 逻辑**:
    *   用户需在“设置”中填入 API Key (如 OpenAI Key)，存储在 localStorage。
    *   Prompt 设计: *"请解释单词 '{word}' 在句子 '{context}' 中的含义，并给出中文释义和音标。"*
    *   流式输出结果到浮动卡片。
*   **保存**: 用户点击“保存”后，将 `word` + `aiExplanation` 存入 `vocabulary` 表。

### 3.3 高亮标注 (Render Hook)
*   **核心挑战**: Lingo-Reader 渲染原理不同于 Epub.js，需在 DOM 生成后进行处理。
*   **实现逻辑**:
    1.  阅读器加载章节内容时，异步从 `vocabulary` 表拉取所有生词。
    2.  创建一个自定义指令 `v-highlight` 或在渲染管线中注入处理函数。
    3.  遍历当前可见的文本节点，使用正则匹配生词。
    4.  **样式替换**: 将匹配到的词替换为 `<span class="vocab-word" data-id="...">word</span>`。
*   **CSS 样式**:
    ```css
    .vocab-word {
        text-decoration: underline;
        text-decoration-style: wavy;
        text-decoration-color: red;
        cursor: pointer;
    }
    ```

### 3.4 生词卡片交互
*   **事件**: 监听 `.vocab-word` 的点击事件。
*   **UI**: 底部弹出抽屉 (Mobile) 或 侧边 Popover (Desktop)。
*   **内容**: 展示之前保存的 AI 解释。提供“删除”或“重新分析”按钮。

---

## 4. 移动端与响应式适配

*   **视口控制**: 确保 `index.html` 包含 `user-scalable=no` meta 标签，防止移动端误缩放。
*   **交互区域**:
    *   翻页区域设为屏幕左右边缘 20%。
    *   中间 60% 区域用于唤起菜单/选中文字。
*   **组件适配**:
    *   AI 解释弹窗：手机端使用 `Bottom Sheet` (底部半屏弹窗)，电脑端使用 `Modal` (居中模态框)。

---

## 5. Vercel 部署方案

### 5.1 环境变量与配置
*   由于 API Key 建议由用户在前端填写（BYOK - Bring Your Own Key 模式），Vercel 端无需配置复杂环境变量。
*   如果在 Vercel 端做 API 代理（为了隐藏 Key），则需配置 `OPENAI_API_KEY` 并在项目中添加 `/api/analyze` 路由 (使用 Vercel Serverless Function)。

### 5.2 构建配置 (`vercel.json` 或 UI 设置)
*   **Framework**: Vite
*   **Build Command**: `npm run build`
*   **Output Directory**: `dist` (注意：lingo-reader 原项目的构建输出目录可能不同，需检查 `vite.config.ts`)。
*   **Rewrites**: 如果使用 HTML5 History 模式路由，需配置重写规则指向 `index.html`。

---

## 6. 开发路线图 (Roadmap)

1.  **Phase 1 (基础改造)**: 引入 Dexie.js，实现文件上传到 IndexedDB，并制作简单的书架网格页。
2.  **Phase 2 (AI 接入)**: 实现设置页 (输入 Key)，实现选中文字弹出菜单并调用 AI 接口显示结果。
3.  **Phase 3 (生词高亮)**: 实现生词入库，编写文本匹配算法，在阅读器中渲染红色波浪线。
4.  **Phase 4 (UI 优化)**: 针对手机端优化触摸操作，美化生词卡片，部署到 Vercel 测试。
